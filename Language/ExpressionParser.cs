//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Expression.g 2012-04-30 14:09:17

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;
using System;
using System.Globalization;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class ExpressionParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "Number", "Space", "'('", "')'", "'*'", "'+'", "'-'", "'/'"
	};
	public const int EOF=-1;
	public const int Number=4;
	public const int Space=5;
	public const int T__6=6;
	public const int T__7=7;
	public const int T__8=8;
	public const int T__9=9;
	public const int T__10=10;
	public const int T__11=11;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public ExpressionParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ExpressionParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ExpressionParser.tokenNames; } }
	public override string GrammarFileName { get { return "Expression.g"; } }


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_parse() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_parse() {}
	// $ANTLR start "parse"
	// Expression.g:7:1: parse returns [double value] : exp EOF ;
	[GrammarRule("parse")]
	public double parse()
	{
		EnterRule_parse();
		EnterRule("parse", 1);
		TraceIn("parse", 1);
	    double value = default(double);


	    double exp1 = default(double);

		try { DebugEnterRule(GrammarFileName, "parse");
		DebugLocation(7, 2);
		try
		{
			// Expression.g:8:3: ( exp EOF )
			DebugEnterAlt(1);
			// Expression.g:8:6: exp EOF
			{
			DebugLocation(8, 6);
			PushFollow(Follow._exp_in_parse29);
			exp1=exp();
			PopFollow();

			DebugLocation(8, 10);
			Match(input,EOF,Follow._EOF_in_parse31); 
			DebugLocation(8, 14);
			value = exp1;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parse", 1);
			LeaveRule("parse", 1);
			LeaveRule_parse();
	    }
	 	DebugLocation(9, 2);
		} finally { DebugExitRule(GrammarFileName, "parse"); }
		return value;

	}
	// $ANTLR end "parse"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_exp() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_exp() {}
	// $ANTLR start "exp"
	// Expression.g:11:1: exp returns [double value] : addExp ;
	[GrammarRule("exp")]
	private double exp()
	{
		EnterRule_exp();
		EnterRule("exp", 2);
		TraceIn("exp", 2);
	    double value = default(double);


	    double addExp2 = default(double);

		try { DebugEnterRule(GrammarFileName, "exp");
		DebugLocation(11, 2);
		try
		{
			// Expression.g:12:3: ( addExp )
			DebugEnterAlt(1);
			// Expression.g:12:6: addExp
			{
			DebugLocation(12, 6);
			PushFollow(Follow._addExp_in_exp51);
			addExp2=addExp();
			PopFollow();

			DebugLocation(12, 13);
			value = addExp2;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exp", 2);
			LeaveRule("exp", 2);
			LeaveRule_exp();
	    }
	 	DebugLocation(13, 2);
		} finally { DebugExitRule(GrammarFileName, "exp"); }
		return value;

	}
	// $ANTLR end "exp"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_addExp() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_addExp() {}
	// $ANTLR start "addExp"
	// Expression.g:15:1: addExp returns [double value] : a= mulExp ( '+' b= mulExp | '-' b= mulExp )* ;
	[GrammarRule("addExp")]
	private double addExp()
	{
		EnterRule_addExp();
		EnterRule("addExp", 3);
		TraceIn("addExp", 3);
	    double value = default(double);


	    double a = default(double);
	    double b = default(double);

		try { DebugEnterRule(GrammarFileName, "addExp");
		DebugLocation(15, 2);
		try
		{
			// Expression.g:16:3: (a= mulExp ( '+' b= mulExp | '-' b= mulExp )* )
			DebugEnterAlt(1);
			// Expression.g:16:6: a= mulExp ( '+' b= mulExp | '-' b= mulExp )*
			{
			DebugLocation(16, 7);
			PushFollow(Follow._mulExp_in_addExp73);
			a=mulExp();
			PopFollow();

			DebugLocation(16, 21);
			value = a;
			DebugLocation(17, 6);
			// Expression.g:17:6: ( '+' b= mulExp | '-' b= mulExp )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=3;
				try { DebugEnterDecision(1, decisionCanBacktrack[1]);
				int LA1_1 = input.LA(1);

				if ((LA1_1==9))
				{
					alt1 = 1;
				}
				else if ((LA1_1==10))
				{
					alt1 = 2;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Expression.g:17:8: '+' b= mulExp
					{
					DebugLocation(17, 8);
					Match(input,9,Follow._9_in_addExp90); 
					DebugLocation(17, 13);
					PushFollow(Follow._mulExp_in_addExp94);
					b=mulExp();
					PopFollow();

					DebugLocation(17, 21);
					value += b;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Expression.g:18:8: '-' b= mulExp
					{
					DebugLocation(18, 8);
					Match(input,10,Follow._10_in_addExp105); 
					DebugLocation(18, 13);
					PushFollow(Follow._mulExp_in_addExp109);
					b=mulExp();
					PopFollow();

					DebugLocation(18, 21);
					value -= b;

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("addExp", 3);
			LeaveRule("addExp", 3);
			LeaveRule_addExp();
	    }
	 	DebugLocation(20, 2);
		} finally { DebugExitRule(GrammarFileName, "addExp"); }
		return value;

	}
	// $ANTLR end "addExp"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_mulExp() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_mulExp() {}
	// $ANTLR start "mulExp"
	// Expression.g:22:1: mulExp returns [double value] : a= unaryExp ( '*' b= unaryExp | '/' b= unaryExp )* ;
	[GrammarRule("mulExp")]
	private double mulExp()
	{
		EnterRule_mulExp();
		EnterRule("mulExp", 4);
		TraceIn("mulExp", 4);
	    double value = default(double);


	    double a = default(double);
	    double b = default(double);

		try { DebugEnterRule(GrammarFileName, "mulExp");
		DebugLocation(22, 2);
		try
		{
			// Expression.g:23:3: (a= unaryExp ( '*' b= unaryExp | '/' b= unaryExp )* )
			DebugEnterAlt(1);
			// Expression.g:23:6: a= unaryExp ( '*' b= unaryExp | '/' b= unaryExp )*
			{
			DebugLocation(23, 7);
			PushFollow(Follow._unaryExp_in_mulExp139);
			a=unaryExp();
			PopFollow();

			DebugLocation(23, 23);
			value = a;
			DebugLocation(24, 6);
			// Expression.g:24:6: ( '*' b= unaryExp | '/' b= unaryExp )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=3;
				try { DebugEnterDecision(2, decisionCanBacktrack[2]);
				int LA2_1 = input.LA(1);

				if ((LA2_1==8))
				{
					alt2 = 1;
				}
				else if ((LA2_1==11))
				{
					alt2 = 2;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// Expression.g:24:8: '*' b= unaryExp
					{
					DebugLocation(24, 8);
					Match(input,8,Follow._8_in_mulExp156); 
					DebugLocation(24, 13);
					PushFollow(Follow._unaryExp_in_mulExp160);
					b=unaryExp();
					PopFollow();

					DebugLocation(24, 23);
					value *= b;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Expression.g:25:8: '/' b= unaryExp
					{
					DebugLocation(25, 8);
					Match(input,11,Follow._11_in_mulExp171); 
					DebugLocation(25, 13);
					PushFollow(Follow._unaryExp_in_mulExp175);
					b=unaryExp();
					PopFollow();

					DebugLocation(25, 23);
					value /= b;

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("mulExp", 4);
			LeaveRule("mulExp", 4);
			LeaveRule_mulExp();
	    }
	 	DebugLocation(27, 2);
		} finally { DebugExitRule(GrammarFileName, "mulExp"); }
		return value;

	}
	// $ANTLR end "mulExp"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_unaryExp() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_unaryExp() {}
	// $ANTLR start "unaryExp"
	// Expression.g:29:1: unaryExp returns [double value] : ( '-' atom | atom );
	[GrammarRule("unaryExp")]
	private double unaryExp()
	{
		EnterRule_unaryExp();
		EnterRule("unaryExp", 5);
		TraceIn("unaryExp", 5);
	    double value = default(double);


	    double atom3 = default(double);
	    double atom4 = default(double);

		try { DebugEnterRule(GrammarFileName, "unaryExp");
		DebugLocation(29, 2);
		try
		{
			// Expression.g:30:3: ( '-' atom | atom )
			int alt3=2;
			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
			int LA3_1 = input.LA(1);

			if ((LA3_1==10))
			{
				alt3 = 1;
			}
			else if ((LA3_1==Number||LA3_1==6))
			{
				alt3 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Expression.g:30:6: '-' atom
				{
				DebugLocation(30, 6);
				Match(input,10,Follow._10_in_unaryExp203); 
				DebugLocation(30, 10);
				PushFollow(Follow._atom_in_unaryExp205);
				atom3=atom();
				PopFollow();

				DebugLocation(30, 15);
				value = -1.0 * atom3;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Expression.g:31:6: atom
				{
				DebugLocation(31, 6);
				PushFollow(Follow._atom_in_unaryExp214);
				atom4=atom();
				PopFollow();

				DebugLocation(31, 15);
				value = atom4;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryExp", 5);
			LeaveRule("unaryExp", 5);
			LeaveRule_unaryExp();
	    }
	 	DebugLocation(32, 2);
		} finally { DebugExitRule(GrammarFileName, "unaryExp"); }
		return value;

	}
	// $ANTLR end "unaryExp"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_atom() {}
	// $ANTLR start "atom"
	// Expression.g:34:1: atom returns [double value] : ( Number | '(' exp ')' );
	[GrammarRule("atom")]
	private double atom()
	{
		EnterRule_atom();
		EnterRule("atom", 6);
		TraceIn("atom", 6);
	    double value = default(double);


	    IToken Number5 = default(IToken);
	    double exp6 = default(double);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(34, 2);
		try
		{
			// Expression.g:35:3: ( Number | '(' exp ')' )
			int alt4=2;
			try { DebugEnterDecision(4, decisionCanBacktrack[4]);
			int LA4_1 = input.LA(1);

			if ((LA4_1==Number))
			{
				alt4 = 1;
			}
			else if ((LA4_1==6))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Expression.g:35:6: Number
				{
				DebugLocation(35, 6);
				Number5=(IToken)Match(input,Number,Follow._Number_in_atom238); 
				DebugLocation(35, 18);
				value = Double.Parse(Number5.Text, CultureInfo.InvariantCulture);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Expression.g:36:6: '(' exp ')'
				{
				DebugLocation(36, 6);
				Match(input,6,Follow._6_in_atom252); 
				DebugLocation(36, 10);
				PushFollow(Follow._exp_in_atom254);
				exp6=exp();
				PopFollow();

				DebugLocation(36, 14);
				Match(input,7,Follow._7_in_atom256); 
				DebugLocation(36, 18);
				value = exp6;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 6);
			LeaveRule("atom", 6);
			LeaveRule_atom();
	    }
	 	DebugLocation(37, 2);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _exp_in_parse29 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_parse31 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _addExp_in_exp51 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mulExp_in_addExp73 = new BitSet(new ulong[]{0x602UL});
		public static readonly BitSet _9_in_addExp90 = new BitSet(new ulong[]{0x450UL});
		public static readonly BitSet _mulExp_in_addExp94 = new BitSet(new ulong[]{0x602UL});
		public static readonly BitSet _10_in_addExp105 = new BitSet(new ulong[]{0x450UL});
		public static readonly BitSet _mulExp_in_addExp109 = new BitSet(new ulong[]{0x602UL});
		public static readonly BitSet _unaryExp_in_mulExp139 = new BitSet(new ulong[]{0x902UL});
		public static readonly BitSet _8_in_mulExp156 = new BitSet(new ulong[]{0x450UL});
		public static readonly BitSet _unaryExp_in_mulExp160 = new BitSet(new ulong[]{0x902UL});
		public static readonly BitSet _11_in_mulExp171 = new BitSet(new ulong[]{0x450UL});
		public static readonly BitSet _unaryExp_in_mulExp175 = new BitSet(new ulong[]{0x902UL});
		public static readonly BitSet _10_in_unaryExp203 = new BitSet(new ulong[]{0x50UL});
		public static readonly BitSet _atom_in_unaryExp205 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_unaryExp214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Number_in_atom238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _6_in_atom252 = new BitSet(new ulong[]{0x450UL});
		public static readonly BitSet _exp_in_atom254 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _7_in_atom256 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
